1. 进程、线程、协程的关系是怎么样的。
   - 进程在某种程度上，是属于应用程序的单位。操作系统会为进程分配独立的内存空间。
   - 线程是被进程包含的，线程是一个具体任务或者逻辑的划分，通常在程序设计过程中，我们期望用多线程来发挥硬件的最大性能，让多个子线程之间减少等待和阻塞的事情发生。
   但是多线程同时还是有缺点，例如，多线程读写同一份数据，这会导致数据错乱，所以要加锁，加锁之后，势必导致有线程会被阻塞，那么运算速度又被下降了。
   - 协程是分配在线程之中的更小时间片，//TODO:
2. 虚拟地址的好处有哪些
   - 保护各自进程的内存空间，
   - 另外一个是让地址空间范围超过实际的内存空间地址，为虚拟内存做准备；
3. OSI五层结构，每层的具体功能有哪些
   - 应用层，与应用进程直接联系，收发数据的最上一层；
   - 传输层，选择是否可靠的传输方式，对于传输的数据包，可供收发确认，控制数据的收发包- 网络层，每个数据包中都包含源地址和目的按地址，提供路由选择。查找MAC地址，为数据链路层提供MAC地址。
   - 数据链路层，收发帧数据包
   - 物理层，最低一层，提供物理链路，建立两个网络节点之间的物理链接。
4. 网络粘包是指什么？
   - 通常发生在TCP内，因为常规的UDP是面向报文的发送数据包，而TCP是面向字节流发送数据包，TCP会选择将数据包拆成多个子包，并且进行收发确认。
   - 通常处理粘包的策略是，在数据包中标记数据的尾部，这样在接收数据的时候能判断出字节流在哪个位置是尾部。解析数据就可以指定字节流长度。
5. 引擎架构分层的细节有哪些？大概能分哪些层？
6. 渲染管线的整体流程
	- 应用阶段
		- CPU提交需要绘制的数据，发起DrawCall
	- 几何阶段
		- 顶点着色器 （顶点数量不变）
		- 曲面细分（顶点数量增加）
		- 几何着色器（顶点数量可能增加也可能减少）
		- 裁剪
		- 映射
	- 光栅化阶段
		- 三角形设置
		- 三角形遍历
		- （提前深度测试）
		- 像素着色器
		- 深度测试
		- 混合
		- Swap Frame
7. 延迟渲染和前向渲染，TBR 与 分簇着色
	- 前向渲染主要是简单，好理解，最符合直觉。但是缺点也很明显:
		- 不好处理多光源情况
		- OverDraw特别明显。即使是不透明物体，也容易出现OverDraw
	- 延迟渲染对多光源的情况，有很大的优化。
		- 计算复杂度下降
		- 场景复杂不再直接影响渲染复杂度，
		- 跟渲染计算关系最紧密的是：分辨率。这个直接影响GBuff设置的Size
	- 延迟渲染也有缺点：
		- 对硬件有硬性要求，要求MRT、对显存带宽也要求
		- 对抗锯齿支持不高，只能TAA，因为延迟渲染，如果用传统的抗锯齿，那么抗锯齿则发生在光照计算之前，这样得到的像素颜色是错误的。
	- TBR 是对多光源、复杂度高的场景的另外一种优化方案。它有如下好处：
		- 对显存带宽有优化作用，场景多数情况下，只是具体修改，这样的优化等同于增量式渲染。对于不变化的格子，不进行渲染更新
		- 将光源数量与二维空间的关系理清楚，减小了光源的计算范围。
		- 这种优化特性，在移动设备上，被大量采用
	- 分簇着色，比较硬核，在Nanite中，被频繁提到，还有Voxel GI 也有提及。//TODO:
8. CPU架构与GPU架构的特点
	- CPU 从远古时期的单核CPU逐渐往多核方向发展，就是为了一种多线程的并行计算更加顺畅。
	- 从操作系统的底层知识可以了解到，操作系统将内存和CPU的时间片进行分配，提出了很多高效率的分配算法。例如时间片：最近最少使用，最优先运算，剩余最少时间调度，甚至为了避免进程一直占用，周期性的调用系统中断指令，来抢先中断恶意的进程，确保操作系统进程能拿回主动权。
	- 多核也是为了调度的分配有更多的选择，对应用户态的进程。调度的优先级，往往是平级的，而多核是为了更好的雨露均沾。
	- 但是CPU多核又引发了数据同步的代价。多核CPU读写同一份数据，如果存在写数据，这里面就涉及数据的写回内存，以及多级缓存数据的更新。这往往是多线程阻塞的主要原因。
	- 而GPU就单纯很多，设计的出发点，就是为了并行运算多个数据，并且设计思路也是保证数据同时写入，批量式操作，读写不冲突。
	- GPU架构里面也包含SM 簇，再细分就是 SM，再往下就是 多个 运算Core,运算Core中包含海量的寄存器，保证更快的读写速度。
9.  渲染方程
10. PBR
11. 寻路算法总结
12. 光线追踪 与 实时运算的策略
13. Lumen 实现原理
14. Nanite 实现原理
15. C++ 特性
16. 物理碰撞检测
17. 布料模拟 PBD算法 
18. 动画细节、IK算法
19. TCP的可靠是怎么保证的
20. 从电路设计上描述，为什么乘法运算快过除法运算
21. 帧同步的步骤有哪些，回滚的触发、帧输入的存储
22. GC回收算法
23. 图像压缩算法
24. Motion Matching
25. Shadow Mapping 算法
26. 可见性算法的剔除
27. 简述，从浏览器输入网址，到最终浏览器显示网页内容的详细步骤
28. 光栅化中，三角形设置所需的重心坐标是如何计算出来的，具体的三个比例值是如何算的？
	- 这里要用上面积的比例来计算
	- 通过面积划分，可以把划分的面积记做A、B、C，然后把比值换算成高度比值。
	- 最后得到高度比值，
	- 例如P点到AB的距离 ： 模长（向量AP X 向量AB）/AB长度 。这个值就是三个比值中的一个，另外两个用一样的计算方式。
29. 傅里叶变换和傅里叶逆变换
30. 蒙特卡洛方法
31. 头发模拟
32. 布料模拟的DCC流程
33. 帧同步的情况下，回滚用的历史帧是怎样运用的
34. 动画重定向的ReTarget的引擎计算底层是怎样的
35. 关于DS服务端的特点。
36. 帧同步的角色控制。动画的RootMotion 方案
37. CIL 与 MONO
38. 采样的重心坐标计算方式
39. UI上显示 3D模型或者特效，怎么处理相机
40. URP、HDRP 的区别、SRP的特性
41. Unity Asmdf 用途
42. HybridCLR  到 编译原理
43. 帧同步下的缓存帧技巧
44. dll 的好处与用途
45. 协程在线程中的设计思想，缺陷与优点