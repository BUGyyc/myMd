


# LockStep



```

对于网络好的玩家（A），可以动态调整（根据动态的latency），让客户端领先服务器少一些，尽量减少预测量，就会尽量减少回滚，例如网络好的，可能客户端只领先2~3帧。

对于网络不好的玩家（B），动态调整，领先服务器多一些，根据latency调整，例如领先5帧。

```

上面所说观点，意思是：如果网络不好，那么需要稍微加快表现？多同步消息给服务器？？
而网络好，确实不需要过多的预测，因为预测越多，错误的可能性越大，当然回滚的次数就越多，通常我们尽可能减少回滚次数。


```
然后还有一个是在逻辑层杜绝Dictionary的使用，Dictionary内存放的数据是无序的，如果需要遍历的话，就会造成AB客户端遍历的顺序不一致，最后导致不同步，如果想要使用字典的话，需要自行实现一个确定顺序的。同样的情况还出现在List.Sort上，Sort的原理是通过快排去实现有序排列的，而快排是不稳定的，所以也需要自行实现排序算法。

```




```
由于玩家不需要明确的下达 idle 一个回合的指令，通常 idle 这种不操作是用超时机制自动触发的。我们一般把 idle 指令的自动执行时刻点放在上一个回合结束时刻点后延大约半个回合周期即可。这个时间点不必特别精确。假设是 50ms ，那么在收到上个回合的信息，推演出沙盘的下个步骤 50ms 后，如果从最后一个发出的指令到这一刻，这段时间内没有操作，就发出 idle 操作。

```




网络环境较差，主动减慢表现层的更新
```
当网络条件不好时，我们也可以想一些办法尽可能地让表现层平滑。例如，在下个回合的逻辑时刻点 20ms 之前再检查一次有没有收齐数据，如果没有，就减慢表现层的时间，推迟下个逻辑时刻点。玩家看起来本地的表现变慢了，但是并没有卡住。如果网络状态转好，又可以加快时钟赶上。

```



网络差的情况，乐观帧锁定？？？

```
例如，你可以做这样一个优化来解决网络不稳定的问题：让权威服务器有权利自行做无操作超时，而不必等待客户端发出超时 idle 指令。

即，如果服务器超过一段时间没有收到某个客户端发过来的指令，就认为它当前回合不操作，并打包整个回合所有玩家指令（或指令计算后的状态结果）广播；如果事后这个客户端的操作晚到，扔掉即可。这样就不会因为有人突然网络断开连接无法发出当前回合的指令，而让所有人都卡住。

```


显示层主动降低频率

```
如果网络状态不好，可能发生的情况就是当前的画面进度超出了逻辑确定帧能确保的范围，那么客户端就可以零界点快到时，开始降低渲染帧率，看起来就是在放慢动作；极端情况下让画面静止卡住等待。
```


---




- 游戏逻辑回滚

    回滚逻辑，就是我们解决问题的方案。可以这样理解，客户端的时间，领先服务器，客户端不需要服务器确认帧返回才执行指令，而是玩家输入，立刻执行（其他玩家的输入，按照其最近一个输入做预测，或者其他更优化的预测方案），然后将指令发送给服务器，服务器收到后给客户端确认，客户端收到确认后，如果服务确认的操作，和之前执行的一样（自己和其他玩家预测的操作），将不做任何改变，如果不一样（预测错误），就会将游戏整体逻辑回滚到最后一次服务器确认的正确帧，然后再追上当前客户端的帧。











- Time Warp




---


帧同步下，GameCore 容器导致不一致


- 一致性：
  - 使用随机种子，
  - 不使用协程
  - 不依赖Dictionary等容器，因为Dictionary容器是不确定顺序的循环、
  - 浮点数精度，转为定点数。
  - 三角函数通过查表实现
  - 控制统一的tick，他是整个战斗逻辑的入口
- 采取的协议：
  - 可靠UDP
  - 冗余信息的UDP
- 逻辑与显示的分离：
  
- 游戏逻辑回滚
- 游戏逻辑快照




<https://www.cnblogs.com/SChivas/p/7898166.html>

<https://zhuanlan.zhihu.com/p/38468615>

<https://blog.codingnow.com/2018/08/lockstep.html>

<http://www.skywind.me/blog/archives/1343#more-1343>

<https://www.bilibili.com/video/BV1ZJ411F7Sn?p=13&vd_source=4ef13c12c37e96927eed265ec739144b>