
- [关于内存](#关于内存)
  - [Untiy检测不到的内存](#untiy检测不到的内存)
  - [Native 内存](#native-内存)
    - [优化 Native 内存](#优化-native-内存)
    - [AssetBundle](#assetbundle)
    - [Texture](#texture)
    - [Mesh](#mesh)
  - [Manager 内存](#manager-内存)
    - [贝母 GC](#贝母-gc)
    - [Incremental GC](#incremental-gc)
    - [慎用闭包和匿名函数](#慎用闭包和匿名函数)
- [CPU](#cpu)
- [GPU](#gpu)
- [Stats 窗口 说明](#stats-窗口-说明)
- [Base](#base)
- [UI 优化](#ui-优化)
  - [NGUI 与 UGUI](#ngui-与-ugui)
  - [OverDraw](#overdraw)
  - [其他](#其他)
- [模型、场景优化](#模型场景优化)
- [内存层面](#内存层面)
- [运行效率优化](#运行效率优化)
  - [代码优化](#代码优化)
  - [缓存池和预处理](#缓存池和预处理)
  - [分帧运行](#分帧运行)
- [渲染优化](#渲染优化)
  - [贴图优化](#贴图优化)
    - [自定义图片格式](#自定义图片格式)
    - [调色板算法](#调色板算法)
  - [定点优化](#定点优化)
    - [优化模型面数](#优化模型面数)
  - [Batch](#batch)
  - [Shader优化](#shader优化)
    - [避免复杂运算](#避免复杂运算)
    - [空间换时间](#空间换时间)
    - [采用效果类似的近似值算法](#采用效果类似的近似值算法)
- [安装包大小优化](#安装包大小优化)
  - [适当降低资源质量与精度](#适当降低资源质量与精度)
  - [按需加载](#按需加载)
- [加载速度优化](#加载速度优化)
  - [网络下载优化](#网络下载优化)
    - [如何突破下载器限制](#如何突破下载器限制)
  - [本地IO优化](#本地io优化)
    - [小文件合并为一个大文件，减少IO](#小文件合并为一个大文件减少io)
- [网络优化](#网络优化)
  - [HTTPS](#https)
  - [TCP](#tcp)
  - [UDP](#udp)
- [Ref](#ref)



# 关于内存

```
Unity内存按照分配方式分为：Native Memory（原生内存）和Managed Memory（托管内存）。Native Memory并不会被系统自动管理，需要手动去释放。而Managed Memory的内存管理是自动的，会通过GC来释放。

```

## Untiy检测不到的内存

即Unity Profilter无法检查到的内存，例如用户分配的Native内存。比如自己写的Native插件（C++插件）导入Unity，这部分Unity是检测不到的，因为Unity没法分析已编译的C++是如何分配和使用内存的。还有就是Lua，它完全自己管理的，Unity也没法统计到它内部的情况。


## Native 内存


### 优化 Native 内存

当构建一个GameObject的时候，实际上在Unity的底层会构建一个或多个Object来存储这一个GameObject的信息（Component信息等）。所以当一个Scene里面有过多的GameObject存在的时候，Native Memory就会显著的上升，甚至可能导致内存溢出。

### AssetBundle

压缩方式的选择：

  Unity主推Lz4（也就是ChunkBased，BuildAssetBundleOptions.ChunkBasedCompression），Lz4非常快，大概是Lzma的十倍左右，但平均压缩比例比Lzma差30%左右，即包体更大。Lz4的算法开源。Lzma基本可以不用了，因为Lzma解压和读取速度都非常慢，并且内存占比高，因为不是ChunkBased，而是Stream，也就是一次全解压出来。ChunkBased可以逐块解压，每次解压可以重用之前的内存，减少内存的峰值。

AssetBundle 包体Size 选择：

    AssetBundle分两部分，一部分是头（用于索引），一部分是实际的打包的数据部分。如果每个Asset都打成一个AssetBundle，那么可能头的部分比数据还大。官方建议一个AssetBundle，在1-2M，但是现在进入5g时代的话，可以适当加大，因为网络带宽更大了。

### Texture 

- Upload Buffer：在Unity 的 Quality 里设置如图，和声音的Buffer类似，填满后向GPU push 一次。
- Read/Write：没必要的话就关闭，正常情况，Texture读进内存解析完了搁到Upload Buffer里之后，内存里那部分就会delete掉。除非开了Read/Write，那就不会delete了，会在显存和内存里各一份。前面说过手机内存显存通用的，所以内存里会有两份。
- ​Mip Maps：例如UI元素这类相对于相机Z轴的值不会有任何变化的纹理，关闭该选项。
- Format：选择合适的Format，可减少占用的空间。
- Alpha Source：对于不透明纹理，关闭其alpha通道。
- Max Size：根据平台不同，纹理的Max Size设成该平台最小值。
- POT：纹理的大小尽量为2的幂次方（POT），因为有些压缩格式可能不支持非2的幂次方的。
- 合并：尽量将多张纹理合并成为大图。
- 压缩：Android设备运行平台要求支持OpenGL ES 3.0的使用ETC2，RGB压缩为RGB Compressed ETC2 4bits，RGBA压缩为RGBA Compressed ETC2 8bits。需要兼容OpenGL ES 2.0的使用ETC，RGB压缩为RGB Compressed ETC 4bits，RGBA压缩为RGBA 16bits。（压缩大小不能接受的情况下，压缩为2张RGB Compressed ETC 4bits）。IOS设备运行平台要求支持OpenGL ES 3.0的使用ASTC，RGB压缩为RGB CompressedASTC 6x6 block，RGBA压缩为RGBA Compressed ASTC 4x4 block。对于法线贴图的压缩精度较高可以选择RGB CompressedASTC 5x5 block。需要兼容OpenGLES 2.0的使用PVRTC，RGB压缩为PVRTC 4bits，RGBA压缩为RGBA 16bits。（压缩大小不能接受的情况下，压缩为2张RGB Compressed PVRTC 4bits）


### Mesh

- Read/Write：同Texture，若开启，Unity会存储两份Mesh，导致运行时的内存用量变成两倍。
- Compression：Mesh Compression是使用压缩算法，将Mesh数据进行压缩，结果是会减少占用硬盘的空间，但是在Runtime的时候会被解压为原始精度的数据，因此内存占用并不会减少。
- Rig：如果没有使用动画，请关闭Rig，例如房子，石头这些。
- Material设置：如果Material没有用到法向量和切线信息，关闭可以减少额外信息。

## Manager 内存

运行于托管堆的内存

### 贝母 GC

Unity用的Boehm GC，简单粗暴，不分代。

- Non-generational（非分代式），即全都堆在一起，因为这样会很快。分代的话就是例如大内存，小内存，超小内存分在不同的内存区域来进行管理（SGen GC的设计思想）。
- Non-Compacting（非压缩式），即当有内存被释放的时候，这块区域就空着。而压缩式的会重新排布，填充空白区域，使内存紧密排布。

上面的形式就会导致内存碎片化，可能当前的内存并不大的时候，添加一块较大内存时，却没有任何的一个空间放得下（即使整体的空间足够），导致内存扩充很多。因此建议先操作大内存，然后操作小内存。


IL2CPP GC机制是Unity重新写的，属于一种升级版的Boehm。

### Incremental GC

Incremental GC（渐进式GC）

主要解决主线程卡顿的问题，现在进行一次GC主线程被迫要停下来，遍历所有的Memory Island，决定哪些要被GC掉，会造成一定时间的主线程卡顿。Incremental GC把前面暂停主线程的事分帧做了，这样主线程不会出现峰值。

### 慎用闭包和匿名函数

所有的匿名函数和闭包在C#编IL代码时都会被new成一个Class（匿名class），所以在里面所有函数，变量以及new的东西，都是要占内存的。



# CPU 



# GPU












AGP RAM ？？？

Tile base Renderer






![(path/to/image.png)](https://raw.githubusercontent.com/BUGyyc/MyGallery/master/res/pic1.png)

# Stats 窗口 说明

![](../../myMd/pic.res/20220430160703.png)  

- Batches
- SetPass Call

# Base 

- GC Alloc
- object 与 GameObject
- 托管堆与非托管堆



# UI 优化


## NGUI 与 UGUI




## OverDraw


![](../../../99.res/pic/20230611102810.png)


![](../../../99.res/pic/20230611102858.png)



## 其他

尽量不要使用 LayoutGroup , 本身有比较大的消耗


# 模型、场景优化

Animation-Instance



---

合批前的排序

![](../../../99.res/pic/20230611143341.png)


排序后，对合批渲染的处理

![](../../../99.res/pic/20230611144048.png)



合批失败

![](../../../99.res/pic/20230611144351.png)



<https://www.bilibili.com/video/BV1p7411j7Bd/?spm_id_from=333.788.recommend_more_video.15&vd_source=4ef13c12c37e96927eed265ec739144b>

---



# 内存层面


![](../../../99.res/pic/20230611090515.png)


https://zhuanlan.zhihu.com/p/370467923

---




# 运行效率优化

运行效率主要影响的是CPU的运行效率，而引起效率下降的主要原因包括但不限于：
- 代码质量
- 频繁创建与销毁对象
- 一帧处理过多计算

## 代码优化

C#语言特性、以及一些托管堆垃圾回收的影响。
装箱与拆箱，使用泛型防止过多的装箱与拆箱操作。

## 缓存池和预处理

缓存池通过提前创建好一些对象，留着备用，用完立即回收到池中，防止频繁创建与销毁。

## 分帧运行

一帧过多的渲染绘制、计算都会导致降帧或者掉帧，
把这一帧内的操作，分到几帧内执行，减少这一帧的执行压力，防止下一帧等待过久。

# 渲染优化

Verts与DrawCall过多都是渲染压力，主要优化也是这两点

## 贴图优化

https://www.cnblogs.com/joeshifu/p/5489906.html

### 自定义图片格式

### 调色板算法

## 定点优化

### 优化模型面数

## Batch


## Shader优化

### 避免复杂运算

### 空间换时间

### 采用效果类似的近似值算法

# 安装包大小优化

## 适当降低资源质量与精度

## 按需加载

# 加载速度优化

## 网络下载优化

### 如何突破下载器限制

## 本地IO优化

### 小文件合并为一个大文件，减少IO

# 网络优化

## HTTPS 

适合网络通信频率较低的场景

## TCP

对延迟不敏感的场景，要求不丢包

## UDP

网络通信频繁，且对延迟敏感的场景



---

# Ref

<https://www.bilibili.com/h5/note-app/view?cvid=11948545&pagefrom=comment>

<https://www.bilibili.com/read/cv3260881>

https://zhuanlan.zhihu.com/p/29087888

https://zhuanlan.zhihu.com/p/29377705

https://zhuanlan.zhihu.com/p/29849244

