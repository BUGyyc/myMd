- [空间换时间、时间换空间](#空间换时间时间换空间)
  - [空间换时间](#空间换时间)
  - [时间换空间](#时间换空间)
- [寻路算法](#寻路算法)
  - [A-Star](#a-star)
  - [JPS(跳点寻路算法)](#jps跳点寻路算法)
    - [JPS 预处理](#jps-预处理)
  - [WayPoint（路点寻路）](#waypoint路点寻路)
  - [B-Star](#b-star)
  - [D-Star](#d-star)
  - [漏斗算法](#漏斗算法)
- [博弈算法](#博弈算法)
  - [预测收益](#预测收益)
  - [剪枝算法](#剪枝算法)
- [几何检测算法](#几何检测算法)
  - [2D 碰撞](#2d-碰撞)
    - [AABB 包围盒](#aabb-包围盒)
    - [凸包 分离轴定理](#凸包-分离轴定理)
  - [3D 碰撞](#3d-碰撞)
- [部分优化相关的算法](#部分优化相关的算法)
  - [模型坍缩](#模型坍缩)
  - [Motion Matching](#motion-matching)
- [RayTrace](#raytrace)
- [四种常规算法](#四种常规算法)
  - [动态规划](#动态规划)
  - [分治](#分治)
  - [回溯](#回溯)
  - [贪心](#贪心)
- [LeetCode](#leetcode)
- [Ref](#ref)



# 空间换时间、时间换空间

在算法中，常常会提到“空间换时间”与“时间换空间”，大致的意思就是指通过特别的手段来降低时间复杂度、空间复杂度，而代价就是稍微牺牲一点空间或时间。

![](../../99.res/pic/20221202102642.png)  

## 空间换时间

空间换时间的例子随处可见，例如：

- 离线生成Shadow、Light;
- 对象池;
- 甚至是GetComponent也可以通过变量存储引用，防止再次取的消耗;

以上这些优化手段大多都是利用存储的方式，把CPU或GPU的运算节省一些。

## 时间换空间

现代计算机的发展，有个特点：CPU、GPU的运算力的增长速度不如存储设备的增长速度快。
或许存储设备的扩展只是在主机机箱中腾出一个足够大的位置，另外存储设备元件体积也越做越小。
因此对于多数中小型游戏来说，存储空间更加廉价，游戏客户端相对在空间中就有了更小的压力，可以相对放肆的使用。
当然也存在部分低端机，存储空间完全不够，所以往往也需要一些手段也优化。

在早些年，很多游戏，例如《超级马里奥》。当时的游戏卡带及其的小，所以多游戏开发也压榨到了极致，游戏内有许多资源是通过翻转变色，从而重复利用。游戏内的音乐也是几个基础音节按照特定数据描述，周期的播放，也就有了背景音乐。

![](../../99.res/pic/20221202103300.png)  

例如 《我的世界》 大世界生成，采取的方法是程序化生成世界，得出的随机数据，转化为世界的构建。

![](../../99.res/pic/20221202103507.png)  

# 寻路算法

在很多导航需求，AI移动需求方面，我们常常需要用上寻路算法，业内常规的寻路算法有：A星、JPS等等。

## A-Star

A*（A-Star)算法是一种静态路网中求解最短路最有效的方法。公式表示为：f(n)=g(n)+h(n)，其中f(n)是节点n从初始点到目标点的估价函数，g(n)是在状态空间中从初始节点到n节点的实际代价，h(n)是从n到目标节点最佳路径的估计代价。

![](../../99.res/pic/20221202104500.png)  


当图结构特别庞大时，需要检索的节点会特别多，导致树的广度特别大，这是因为OpenList内太多节点需要进行比较，这时我们需要减少OpenList内的节点。

## JPS(跳点寻路算法)

当我们了解了A星之后，我们注意到OpenList过大一定会导致节点的比较次数增大，另外我们发现 Grid 类型的世界，很多节点是可以不用考虑到寻路内的。

![](../../99.res/pic/20221202115732.png)  


### JPS 预处理

注意，预处理只能应用于静态地图，因为只有静态地图才是一种确定性的搜索。

情况一，对角的连通判断，例如每个障碍物，存在四个对角节点，若节点满足：节点非障碍物，并且有连通性。如图：

![](../../99.res/pic/20221202121910.png)  


解读如下：例如 E 是障碍物，那么 E 存在四个对角：A、B、C、D。

如下图，分析情况：
- D 节点是障碍物，所以 D不是跳点。
- B 节点没有连通性，B 可以从西到东，但是B不能从北到南，因为B的南向是障碍物，所以B不是跳点。
- A 节点不是障碍物，并且可以从南到北，可以从东到西，有连通性，所以是跳点。
- C 节点不是障碍物，并且可以从北到南，可以从东到西，有连通性，所以是跳点。

![](../../99.res/pic/20221202122532.png)  

直线方向上的判断。我们先从简单的情况开始，我们从左到右检查，按照ABCDEF的顺序检索下去。如下图所示：

![](../../99.res/pic/20221202152608.png)  

A节点的强制邻居是右和下，所以我们画上的红色箭头。然后依次给B和D也画上。

如下图，我们来分析ABCDEF的向西（West）方向的值，这个值其实就是标注特别的跳点距离。注意是特别的跳点。

- B.West = 1，因为A.East 是满足强制邻居条件的，B和A的距离是1，所以B.West = 1
- C.West = 1, 因为B.East 也满足条件，C和B的距离是1
- D.West = 2, 因为B比A更近，距离为2
- E.West = 3, 同上理由
- E.West = 4, 同上理由

![](../../99.res/pic/20221202153139.png)  

记录距离，如下：

![](../../99.res/pic/20221202140838.png)  




## WayPoint（路点寻路）

并不是所有的游戏世界都能用 Grid 来描述的。

这种方式的寻路，还是有不少好处，对策划同学特别友好。

<https://zhuanlan.zhihu.com/p/194888259>


- 可配置的路径消耗
- 可控的有向图与无向图，直接实现人群靠右行走<https://www.zhihu.com/zvideo/1339900170771976192>


## B-Star

## D-Star

## 漏斗算法

# 博弈算法

## 预测收益

## 剪枝算法



# 几何检测算法

## 2D 碰撞

### AABB 包围盒

### 凸包 分离轴定理

## 3D 碰撞

# 部分优化相关的算法

## 模型坍缩

## Motion Matching



# RayTrace

# 四种常规算法

## 动态规划

## 分治

## 回溯

## 贪心

# LeetCode


---

# Ref

<https://zhuanlan.zhihu.com/p/385733813>

<https://www.cnblogs.com/KillerAery/p/12242445.html>
