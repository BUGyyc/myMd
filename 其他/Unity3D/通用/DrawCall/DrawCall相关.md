
Unity DrawCall 相关

 首先我来简单讲讲什么是DC吧，这是我在一篇写的很好的博客上看到的，他是这样讲的，DC就是在每次绘图前，我们都需要先准备好顶点数据（位置、法线、颜色、纹理坐标，切线等），然后调用一系列API把它们放到GPU可以访问到的指定位置，最后，我们需要调用_glDraw*命令，来告诉GPU，“嘿嘿，我把东西都准备好了，你个懒家伙赶紧出来干活（渲染）吧！”。而调用_glDraw*命令的时候，就是一次DC。那么为什么DC会成为性能瓶颈呢（而且是CPU的瓶颈）？上面说到过，我们想要绘制图像时，就一定需要调用DC，而这DC就是在CPU下执行的。

 前面说过了，DC是CPU调用底层图形接口。比如有上千个物体，每一个的渲染都需要去调用一次底层接口，而每一次的调用CPU都需要做很多工作，那么CPU必然不堪重负。但是对于GPU来说，图形处理的工作量是一样的。所以对DC的优化，主要就是为了尽量解放CPU在调用图形接口上的开销。所以针对DC我们主要的思路就是每个物体尽量减少渲染次数，多个物体最好一起渲染。所以，按照这个思路就有了以下几个方案：


使用DC Batching，也就是描绘调用批处理。Unity在运行时可以将一些物体进行合并，从而用一个描绘调用来渲染他们。具体下面会介绍。
通过把纹理打包成图集来尽量减少材质的使用。
尽量少的使用反光，阴影啦之类的，因为那会使物体多次渲染。
使用Occlusion Culling算法，减少可见的物体数量同时也可以减少Draw Call。
删除不必要的Shader中的Pass通道，因为一个Pass对应一个DC。




















---
https://blog.csdn.net/u3d_ysj/article/details/47906035
