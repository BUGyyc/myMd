
# 前言

在进行多人游戏开发过程中，我们期望游戏在不同设备上保持一致的表现，或者说是结果一致，在许多动作类游戏，多人游戏的要求就更高，我们不希望不同客户端看到的结果是不一样的，
这要求我们要保证物理计算的一致，包括随机数，
以及预测式输入，我们不希望长时间等待服务器响应，当然我们在网络波动延迟较大的情况下，可以做出相应的提示，让玩家感知到当前网络较差，

- 插值处理
线性的插值，在单纯的直线运动，我们可以直接采取，k*x+b = y的方式，得到中间值(x,y)。在update中去lerp
- 光滑曲线的插值计算
- 三次样条插值，填补掉帧或延迟造成坐标跳跃，所以我们希望计算中间值，确定平滑曲线，得到最终的路径点
- 定点数计算
设备浮点数计算是有误差的，所以必要时候舍弃设备自带的四舍五入方式，采取手写确定，保持计算一致
客户端，有时候喜欢随机值单独计算，例如，玩家攻击的是否暴击，随机种子保证随机序列，只要保证，随机执行的顺序


---

# 插值与补偿

## 线性插值

直线式的补偿，可以满足要求不高的同步游戏。
线性插值其实是取当前点与网络目标点，得到线段，并且得到线段的线性函数，k*x+b = y 。只需求解k,b，在进行插值时，我们已知两个点（当前点与网络同步过来的目标点），已知两个不重合的点，可以求出直线方程，所有k,b求出结果。


### 线性内插

根据帧数差和实际需求，我们确定一个系数，线性内插系数的取值范围是[0,1]，系数为0是当前点，系数为1是目标点。通常可以放在update中，或者协程中。


### 线性外插

系数取值不在[0,1]范围内，得到的是范围外的点，不过依然是在直线k*x+b上，只是处在线段外而已。


https://www.cnblogs.com/luluathena/archive/2010/11/27/1889906.html


## 双线性插值

https://www.cnblogs.com/linkr/p/3630902.html


## 三次样条插值

是属于高阶的插值方式

a*x^3+b*x^2+c*x+d = y;

求解a,b,c,d

https://zhuanlan.zhihu.com/p/62860859

贪吃蛇的实现方式

客户端与服务器保持一致的三次样条插值方式，服务器采取10帧计算频率，客户端保持40帧左右的更新频率，也就是说客户端插值计算得到空缺帧的中间点，使得蛇可以沿着曲线光滑移动。

---
# 确定性问题

不同设备计算的不确定性

## 浮点数计算

浮点计算因为设备硬件差异，会有计算误差，所以必要时候，需要定点计算，提供一个定点计算数学库

之前的站桩英雄，标枪转角就是按照每帧改变速度来实现，标枪的抛物线运动效果，首先确定一个帧率，保证低配手机的帧率和其他手机一致

基本30-40帧就足够了，其次速度改变是有计算过程的，这个过程可能有计算误差，源头就是设备差异，浮点计算结果不一致，那么单独写一个向量计算的定点数实现方法就可以基本忽略这个问题了

https://gameinstitute.qq.com/community/detail/122467

## 物理引擎的确定性

### box2D

### physicX

---
# 传输协议的选择

## TCP

面向连接的、可靠的、基于字节流的传输层通信协议。

### 为什么TCP具有可靠性

- 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。
- 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。
- TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输
过程中的任何变化。如果收到段的检验和有差错， TCP将丢弃这个报文段和不确认收到
此报文段（希望发端超时并重发）。
- 既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此 TCP报文段
的到达也可能会失序。如果必要， TCP将对收到的数据进行重新排序，将收到的数据以
正确的顺序交给应用层。
-  既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。
-  TCP还能提供流量控制。 TCP连接的每一方都有固定大小的缓冲空间。 TCP的接收端只
- 允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲
区溢出。

https://github.com/BUGyyc/myMd/blob/master/%E7%BD%91%E7%BB%9C/TCP.md

## UDP
UDP是面向报文的。
发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。
既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。

https://github.com/BUGyyc/myMd/blob/master/%E7%BD%91%E7%BB%9C/UDP.md

## KCP
TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而KCP是水流湍急的小激流。KCP有正常模式和快速模式两种，通过以下策略达到提高流速的结果：

- 选择性重传 vs 全部重传: TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。
- 快速重传：发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。
- 延迟ACK vs 非延迟ACK：TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大 RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟发送可以调节。
- 非退让流控：

https://github.com/skywind3000/kcp

## UDP实现可靠传输问题

事实上，有不少行家指出，UDP基础上实现可靠传输存在许多无法预料的问题


---

# 同步策略

- 事件锁定
- 时间同步
- 锁步协议

---

# Unet
Unity官方提供了NetworkManager的方式
如下运行结果：左边操作，右边同步更新

git

https://github.com/BUGyyc/SyncProject

---


# 其他

https://blog.csdn.net/yupu56/article/details/86822511

https://blog.codingnow.com/2006/04/sync.html

https://zhuanlan.zhihu.com/p/28617637

https://zhuanlan.zhihu.com/p/44341238

https://zhuanlan.zhihu.com/p/49482294

http://gad.qq.com/program/translateview/7168875

https://zhuanlan.zhihu.com/p/49483467

https://zhuanlan.zhihu.com/p/49483875


https://zhuanlan.zhihu.com/p/50440945