# buff的本质

首先我们从最粗浅的角度来认识BUFF，BUFF其实就是对一些基础属性、状态等数据的修改。基本上，可以概括为对属性数据的修改，例如：移动速度、血量等修改，增益或者损耗。

# 设计的思路

## 不太可取的思路

将buff设计为一个阶段性的效果。
如：
开始生效：增加移动速度5。
结束BUFF：减少移动速度。
这样设计意味着需要在结束BUFF时进行一次逆运算，就是将属性数据修改为未生效之前，这里很容易出现错误。
例如精度的问题。
某个BUFF生效，使得移动速度变为原来的1/3.
基础移动速度 = 10
开始生效后，移动速度 = 10/3
如精度控制后，保留4位小数，移动速度为 3.3333
当BUFF结束后，我们需要将移动速度还原，3.3333*3 != 10.
为了解决这类问题，可能会采取以下方案：
- 以分数的形式，做运算，这样可以解决，但又将属性数据做了进一步扩展，变成了分数形式，不是一个好方案。
- 可以将BUFF生效前的移动速度保存起来，但是这意味着需要在每个BUFF效果中存储一个BUFF生效前的属性数据。不推荐。

## 推荐的思路

通常BUFF的设计，特别是比较复杂的BUFF系统设计，往往需要策划进行BUFF计算公式的确定。如上文提到的移动速度。
可以参考如下计算：
移动速度 = 基础移动速度 * 增幅 + 增值；
增幅、增值都是可取负数。
在多个BUFF生效时，也是如此进行计算，多个BUFF生效改变的是增幅和增值。

    Zf = Zf1+Zf2+...+Zfn;//增幅累积
    Zz = Zz1+Zz2+...+Zzn;//增值累积

当然上面提及的公式累积不是通用的方式，这个要看具体的需求来定。
比较可靠的方式都是采取两套数据，一个是基础数据，另一个就是运行的临时数据。这使得断线重连等复杂环境，依然有机会恢复到正确的状态。

BUFF系统的执行频率并不一定需要每帧执行，所以往往是如下执行方式：


    class BuffSystem{

        //某个玩家身上的全部需要执行的BUFF列表
        public List<Buff> list;
        
        ...

        public void Execute(){
            foreach(var buff in list){
                buff.DoExecute(Time.deltaTime);
                remove buff;
            }
        }
    }

# BUFF 的结构探讨

通常我们希望buff本身能够在客户端预表现，特别是在状态同步的设计下需要客户端预表现，因为BUFF对属性的修改往往难以及时推送到客户端，当然我们可以另外加网络协议来保证数据的实时性，但是尽量不要采取这种做法，这样太繁琐了，我们希望客户端预表现，独立计算出表现的值。
所以大概的结构应当如下：

    startTime;
    keepLiveTime;
    lastEffectTime;
    count;
